if (process.env.NODE_ENV !== 'production') {
  require('dotenv').config();
} // Aseg√∫rate de que dotenv est√© configurado al inicio
const OpenAI = require('openai');

// La clave de la API se carga autom√°ticamente desde las variables de entorno (process.env.OPENAI_API_KEY)
const openai = new OpenAI();

/**
 * Analiza el texto de una conversaci√≥n de WhatsApp y extrae los datos del pedido en formato JSON.
 * Detecta si es un pastel Normal o Base/Especial y extrae la estructura correspondiente.
 * @param {string} conversationText - El texto completo de la conversaci√≥n con el cliente.
 * @returns {Promise<object>} - Un objeto con los datos del folio extra√≠dos.
 */
async function getInitialExtraction(conversationText) {
    const today = new Date().toLocaleDateString('es-MX', {
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
    });

    // ===== PROMPT ACTUALIZADO PARA DETECCI√ìN Y ESTRUCTURACI√ìN DE BASE/ESPECIAL =====
    const prompt = `
        Eres un asistente experto para una pasteler√≠a llamada "La Fiesta". Tu tarea es analizar la siguiente conversaci√≥n de WhatsApp
        y extraer la informaci√≥n clave para generar un folio de pedido en formato JSON. La fecha de hoy es ${today}.

        **Instrucciones Generales:**
        1.  **Analiza la conversaci√≥n:** Lee todo el texto para entender los detalles del pedido.
        2.  **Interpreta fechas y horas:** Convierte fechas relativas (ej. "ma√±ana", "el pr√≥ximo lunes") a formato AAAA-MM-DD. Convierte horas a formato HH:MM:SS de 24 horas.
        3.  **Formato de Salida:** Responde √∫nicamente con un objeto JSON v√°lido, sin ning√∫n texto adicional antes o despu√©s.

        **Instrucciones Espec√≠ficas para Tipo de Folio y Estructura:**
        1.  **Detecta el Tipo de Folio:**
            * Si la conversaci√≥n menciona expl√≠citamente "pisos", "bases", "pastel especial", "de base", o describe claramente diferentes secciones/pisos del pastel con distintas caracter√≠sticas (personas, panes, rellenos por secci√≥n), establece \`folioType\` como \`"Base/Especial"\`.
            * En cualquier otro caso, establece \`folioType\` como \`"Normal"\`.
        2.  **Extrae Datos seg√∫n el Tipo:**
            * **Si es "Normal":**
                * Extrae los sabores generales en el array \`cakeFlavor\`. Pueden ser hasta 2.
                * Extrae los rellenos generales en el array \`filling\`. Pueden ser hasta 2.
                * Deja el campo \`tiers\` como \`null\` o un array vac√≠o \`[]\`.
            * **Si es "Base/Especial":**
                * **Deja los campos \`cakeFlavor\` y \`filling\` como \`null\` o arrays vac√≠os \`[]\`**. La informaci√≥n ir√° en \`tiers\`.
                * Analiza la descripci√≥n de cada piso y crea un array de objetos en el campo \`tiers\`.
                * Cada objeto dentro de \`tiers\` DEBE tener la siguiente estructura exacta:
                    \`\`\`
                    {
                      "persons": number,      // Personas para ESE piso
                      "panes": [string, string, string], // Intenta extraer 3 sabores de pan para el piso. Si solo mencionan uno, rep√≠telo 3 veces. Si mencionan dos, a√±ade el primero de nuevo al final. Si no mencionan, usa [null, null, null].
                      "rellenos": [string, string], // Intenta extraer 2 rellenos para el piso. Si solo mencionan uno, a√±√°delo y pon el segundo como null. Si no mencionan o no aplica (ej. pan queso), usa [null, null].
                      "notas": string | null  // Notas adicionales o forma espec√≠fica del piso (opcional)
                    }
                    \`\`\`
                * Aseg√∫rate de que \`persons\` en el nivel ra√≠z del JSON siga siendo el n√∫mero total de personas para todo el pedido (la suma de las personas de los pisos si est√° disponible, o el total mencionado).

        **Reglas Adicionales:**
        * **Dedicatoria:** Si encuentras frases como "que diga '...'", "con el texto '...'", o una frase entre comillas que deba ir en el pastel, extrae ese texto EXCLUSIVAMENTE en el campo \`dedication\`. NO incluyas la dedicatoria en \`designDescription\`.
        * **Direcci√≥n:** Intenta formatear como "Calle y N√∫mero, Colonia Nombre de la Colonia" en \`deliveryLocation\`. Si es "recoge en tienda", usa ese texto exacto. Si es "env√≠a ubicaci√≥n por Maps", usa "El cliente env√≠a ubicaci√≥n (Google Maps)".
        * **Valores Num√©ricos:** Extrae solo el n√∫mero para \`deliveryCost\`, \`total\`, \`advancePayment\`. Si no se mencionan, usa \`null\`.

        **Campos a extraer (adapta seg√∫n el folioType detectado):**
        - \`folioType\`: (String) "Normal" o "Base/Especial". **Obligatorio**.
        - \`clientName\`: (String | null) Nombre del cliente.
        - \`clientPhone\`: (String | null) Tel√©fono (si se menciona).
        - \`deliveryDate\`: (String | null) Fecha de entrega (YYYY-MM-DD).
        - \`deliveryTime\`: (String | null) Hora de entrega (HH:MM:SS).
        - \`persons\`: (Number | null) N√∫mero TOTAL de personas para el pedido completo. **Obligatorio**.
        - \`shape\`: (String | null) Forma general del pastel (ej. "Redondo", "Rectangular").
        - \`cakeFlavor\`: (Array of Strings | null) Sabores generales del pan (SOLO para tipo "Normal").
        - \`filling\`: (Array of Strings | null) Rellenos generales (SOLO para tipo "Normal").
        - \`tiers\`: (Array of Objects | null) Estructura por pisos (SOLO para tipo "Base/Especial", sigue la estructura definida arriba).
        - \`designDescription\`: (String | null) Descripci√≥n detallada de la decoraci√≥n (SIN dedicatoria).
        - \`dedication\`: (String | null) Texto de la dedicatoria.
        - \`deliveryLocation\`: (String | null) Direcci√≥n de entrega o "recoge en tienda".
        - \`deliveryCost\`: (Number | null) Costo del env√≠o (solo n√∫mero).
        - \`total\`: (Number | null) Costo total o del pastel (solo n√∫mero).
        - \`advancePayment\`: (Number | null) Anticipo (solo n√∫mero).

        **Conversaci√≥n a analizar:**
        ---
        ${conversationText}
        ---
    `;

    try {
        console.log("ü§ñ Iniciando extracci√≥n inicial con IA...");
        const response = await openai.chat.completions.create({
            model: "gpt-4o", // Usamos gpt-4o por su mejor capacidad para seguir instrucciones complejas y estructurar JSON
            messages: [{ role: "system", content: prompt }],
            response_format: { type: "json_object" }, // Forzar salida JSON
        });

        const extractedJsonString = response.choices[0].message.content;
        console.log("ü§ñ Datos extra√≠dos por la IA (Extracci√≥n Inicial - Raw):", extractedJsonString);

        // Validaci√≥n b√°sica antes de parsear
        if (!extractedJsonString || !extractedJsonString.trim().startsWith('{') || !extractedJsonString.trim().endsWith('}')) {
             console.error("Respuesta inv√°lida de OpenAI:", extractedJsonString);
             throw new Error("La respuesta de la IA no fue un objeto JSON v√°lido.");
        }

        let extractedData;
        try {
            extractedData = JSON.parse(extractedJsonString);
        } catch (parseError) {
             console.error("Error al parsear JSON de OpenAI:", parseError, "JSON recibido:", extractedJsonString);
            throw new Error(`Error al interpretar la respuesta de la IA: ${parseError.message}`);
        }


        // --- Validaciones y Aseguramiento de Tipos ---
        const requiredKeys = ['folioType', 'persons', 'deliveryDate']; // Campos m√≠nimos esperados
        for (const key of requiredKeys) {
            if (!(key in extractedData) || extractedData[key] === null || extractedData[key] === undefined) {
                 console.warn(`Advertencia: La IA no extrajo el campo obligatorio '${key}'. Se intentar√° continuar, pero puede causar errores.`);
                 // Podr√≠as establecer un valor por defecto o lanzar un error m√°s estricto si lo prefieres
                 // extractedData[key] = null; // Ejemplo: asegurar que exista aunque sea nulo
            }
        }

        // Asegurar que 'persons' sea un n√∫mero
        if (extractedData.persons && typeof extractedData.persons !== 'number') {
            const parsedPersons = parseInt(extractedData.persons, 10);
            extractedData.persons = !isNaN(parsedPersons) ? parsedPersons : null;
        }

        // Asegurar que folioType sea uno de los valores permitidos, si no, default a Normal
        if (!['Normal', 'Base/Especial'].includes(extractedData.folioType)) {
            console.warn(`folioType inv√°lido ('${extractedData.folioType}') recibido de la IA. Se usar√° 'Normal' por defecto.`);
            extractedData.folioType = 'Normal';
        }

        // Limpieza condicional basada en folioType (asegurar consistencia)
        if (extractedData.folioType === 'Base/Especial') {
            extractedData.cakeFlavor = null; // O []
            extractedData.filling = null;    // O []
            if (!Array.isArray(extractedData.tiers)) {
                console.warn("folioType es Base/Especial pero 'tiers' no es un array. Se establecer√° a [].");
                extractedData.tiers = [];
            }
        } else { // Si es 'Normal'
            extractedData.tiers = null; // O []
             if (!Array.isArray(extractedData.cakeFlavor)) extractedData.cakeFlavor = [];
             if (!Array.isArray(extractedData.filling)) extractedData.filling = [];
        }

        // Convertir campos num√©ricos que puedan venir como string
        ['deliveryCost', 'total', 'advancePayment'].forEach(key => {
            if (extractedData[key] && typeof extractedData[key] === 'string') {
                const num = parseFloat(extractedData[key]);
                extractedData[key] = isNaN(num) ? null : num;
            } else if (extractedData[key] === undefined) {
                extractedData[key] = null;
            }
        });

        console.log("‚úÖ Datos extra√≠dos y procesados:", JSON.stringify(extractedData, null, 2));
        return extractedData;

    } catch (error) {
        console.error("‚ùå Error en getInitialExtraction:", error);
        // Devolver un objeto de error estructurado podr√≠a ser √∫til para el controlador
        throw new Error(`Error durante la extracci√≥n inicial con IA: ${error.message}`);
    }
}

module.exports = { getInitialExtraction };